{"version":3,"sources":["util.js","../node_modules/domready/ready.js","scroll-reveal/index.js","count-up/index.js","index.js"],"names":["mapOptions","el","defaultOptions","dataOptions","Object","keys","reduce","optionName","attr","camelCaseToDash","value","getAttribute","s","replace","toLowerCase","elemsToWatch","start","opts","options","push","isInView","callback","stop","forEach","i","splice","scroll","window","scrollY","pageYOffset","boundsTop","getBoundingClientRect","top","viewport","innerHeight","bounds","clientHeight","raf","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","setTimeout","scrollHandler","handler","addEventListener","settings","test","innerHTML","_countUpOrigInnerHTML","lang","hasLang","divisions","duration","delay","splitValues","splitNumbers","nums","k","length","num","isCountable","format","detectNumFormat","applyNumFormat","style","visibility","countUpTimeout","output","shift","undefined","text","split","generateNumbersTo","finalNumber","len","increment","numbers","Array","fill","map","v","strNum","decimalPlaces","hasComma","Intl","NumberFormat","parseInt","scrollReveal","countUp"],"mappings":"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","file":"effectbox.min.map","sourceRoot":"../src","sourcesContent":["export const mapOptions = ( el, defaultOptions ) => {\n    const dataOptions = Object.keys( defaultOptions ).reduce( ( dataOptions, optionName ) => {\n        const attr = `data-${camelCaseToDash( optionName )}`\n        const value = el.getAttribute( attr )\n        if ( value ) {\n            dataOptions[ optionName ] = value\n        }\n        return dataOptions\n    }, {} )\n    return {\n        ...defaultOptions,\n        ...dataOptions,\n    }\n}\n\nexport const camelCaseToDash = s => s.replace( /([a-zA-Z])(?=[A-Z])/g, '$1-' ).toLowerCase()","/*!\n  * domready (c) Dustin Diaz 2014 - License MIT\n  */\n!function (name, definition) {\n\n  if (typeof module != 'undefined') module.exports = definition()\n  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)\n  else this[name] = definition()\n\n}('domready', function () {\n\n  var fns = [], listener\n    , doc = document\n    , hack = doc.documentElement.doScroll\n    , domContentLoaded = 'DOMContentLoaded'\n    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)\n\n\n  if (!loaded)\n  doc.addEventListener(domContentLoaded, listener = function () {\n    doc.removeEventListener(domContentLoaded, listener)\n    loaded = 1\n    while (listener = fns.shift()) listener()\n  })\n\n  return function (fn) {\n    loaded ? setTimeout(fn, 0) : fns.push(fn)\n  }\n\n});\n","import domready from 'domready'\n\nexport const elemsToWatch = []\n\nconst start = ( el, opts = {} ) => {\n    stop( el )\n    const options = {\n        callback: () => {},\n        ...opts,\n    }\n    elemsToWatch.push( { el, options, } )\n    if ( isInView( el, options ) ) {\n        options.callback()\n        stop( el )\n    }\n}\n\nconst stop = ( el ) => {\n    elemsToWatch.forEach( ( { el: existingEl }, i ) => {\n        if ( existingEl === el ) {\n            elemsToWatch.splice( i, 1 )\n        }\n    } )\n}\n\nexport const isInView = ( el, options ) => {\n    const scroll = window.scrollY || window.pageYOffset\n    const boundsTop = el.getBoundingClientRect().top + scroll\n    \n    const viewport = {\n        top: scroll,\n        bottom: scroll + window.innerHeight,\n    }\n    \n    const bounds = {\n        top: boundsTop,\n        bottom: boundsTop + el.clientHeight,\n    }\n    \n    return ( bounds.bottom >= viewport.top && bounds.bottom <= viewport.bottom ) \n        || ( bounds.top <= viewport.bottom && bounds.top >= viewport.top );\n}\n\nconst raf = \n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    function( callback ) {\n        window.setTimeout( callback, 1000 / 60 )\n    }\n\nexport const scrollHandler = () => {\n    elemsToWatch.forEach( ( { el, options } ) => {\n        if ( isInView( el, options ) ) {\n            options.callback()\n            stop( el )\n        }\n    } )\n}\n\nexport default {\n    start,\n    stop,\n} \n\ndomready( () => {\n    const handler = () => raf( scrollHandler )\n    handler()\n    window.addEventListener( 'scroll', handler )\n    window.addEventListener( 'resize', handler )\n} )","import { mapOptions } from '../util'\nimport scrollReveal from '../scroll-reveal'\n\nconst start = ( el, options = {} ) => {\n\n    const defaults = {\n        lang: '',\n        duration: 1000,\n        delay: 16,\n    }\n\n    const settings = {\n        ...mapOptions( el, defaults ),\n        ...options,\n    }\n\n    stop( el );\n\n    // If no number, don't do anything.\n    if ( ! /[0-9]/.test( el.innerHTML ) ) {\n        return;\n    }\n\n    // Remember the element.\n    el._countUpOrigInnerHTML = el.innerHTML;\n    const hasLang = !! el.getAttribute( 'data-lang' ) || !! options.lang;\n\n    // Number of times the number will change.\n    const divisions = settings.duration / settings.delay;\n\n    // Split numbers and html tags.\n    const splitValues = splitNumbers( el.innerHTML );\n\n    // Contains all numbers to be displayed.\n    const nums = [];\n\n    // Set blank strings to ready the split values.\n    for ( let k = 0; k < divisions; k++ ) {\n        nums.push( '' );\n    }\n\n    // Loop through all numbers and html tags.\n    for ( let i = 0; i < splitValues.length; i++ ) {\n\n        let num = splitValues[ i ];\n\n        if ( isCountable( num ) ) {\n\n            const format = detectNumFormat( num )\n            num = num.replace( /,/g, '' );\n\n            generateNumbersTo( num, divisions ).forEach( ( num, i ) => {\n                nums[ i ] += applyNumFormat( num, format, settings.lang )\n            } )\n\n        } else {\n\n            // Insert all non-numbers in the same place.\n            for ( let k = 0; k < divisions; k++ ) {\n                nums[ k ] += num;\n            }\n        }\n    }\n\n    el.innerHTML = nums[0];\n    el.style.visibility = 'visible';\n\n    const callback = () => {\n\n        // Function for displaying output with the set time and delay.\n        const output = function() {\n            el.innerHTML = nums.shift();\n            if ( nums.length ) {\n                clearTimeout( el.countUpTimeout );\n                el.countUpTimeout = setTimeout( output, settings.delay );\n            } else {\n                el._countUpOrigInnerHTML = undefined;\n            }\n        };\n        el.countUpTimeout = setTimeout( output, settings.delay );\n    }\n\n    scrollReveal.start( el, {\n        callback\n    } )\n}\n\nconst stop = ( el ) => {\n    clearTimeout( el.countUpTimeout );\n\tif ( el._countUpOrigInnerHTML ) {\n\t\tel.innerHTML = el._countUpOrigInnerHTML;\n\t\tel._countUpOrigInnerHTML = undefined;\n\t}\n\tel.style.visibility = '';\n}\n\nexport default {\n    start,\n    stop,\n} \n\n// Given a string that can have HTML, split it to separate the numbers.\nexport const splitNumbers = ( text ) => text.split(/(<[^>]+>|[0-9.][,.0-9]*[0-9]*)/)\n\n// Countable string\nexport const isCountable = ( num ) => /([0-9.][,.0-9]*[0-9]*)/.test( num ) && ! /<[^>]+>/.test( num )\n\n// Creates an array of numbers from zero to num\nexport const generateNumbersTo = ( finalNumber, len ) => {\n    if ( len < 1 ) {\n        return [ finalNumber ]\n    }\n    const increment = finalNumber / len;\n    const numbers = Array( len - 1 ).fill( 0 ).map( ( v, i ) => ( i + 1 ) * increment )\n    numbers.push( finalNumber ) // Ensure that the last number is the original one.\n    return numbers\n}\n\nexport const detectNumFormat = ( strNum ) => {\n\n    let decimalPlaces = 0\n    if ( /^[0-9]+\\.[0-9]+$/.test( strNum ) ) {\n        decimalPlaces = ( strNum.split( '.' )[1] || [] ).length\n    }\n            \n    return {\n        hasComma: /[0-9]+,[0-9]+/.test( strNum ),\n        decimalPlaces,\n    }\n}\n\nexport const applyNumFormat = ( num, format, lang = '' ) => {\n\n    const { hasComma, decimalPlaces } = format\n\n    if ( decimalPlaces || lang || hasComma ) {\n        return Intl.NumberFormat( lang ? lang : undefined, { \n            minimumFractionDigits: decimalPlaces,\n            maximumFractionDigits: decimalPlaces,\n        } ).format( num );\n    }\n\n    return parseInt( num, 10 )\n}","import countUp from './count-up'\nexport { countUp }\n\nimport scrollReveal from './scroll-reveal'\nexport { scrollReveal }\n"]}